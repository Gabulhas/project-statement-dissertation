\chapter{Use Case: Developing and Testing a New Protocol}

Building on the previous chapter's conclusion, the focus of this chapter is to demonstrate the practical utility of the tools we've developed—namely, the Bootstrapper and the Live Testing Tool—in a real-world development scenario. The objective is to provide a comprehensive view of how these tools can be seamlessly integrated to facilitate the development and testing phases of a blockchain protocol.

To achieve this, we chose to implement a Proof of Authority protocol. While this protocol shares some similarities with the previously implemented Proof of Work, its core consensus mechanism is fundamentally different. This serves as an excellent case study to showcase the capabilities of our tools. The Bootstrapper was used to automate the initial setup and coding tasks, while the Live Testing Tool provided a live environment for performance evaluation and fine-tuning. This chapter shows how these tools work together to make creating a protocol faster and easier.



\section{Goals and Approach}
The primary aim of this chapter is to implement a Proof of Authority protocol. We intend to start the development process using the Bootstrapper tool to set up the initial codebase. Following this, we will write tests specifically designed to evaluate the protocol's performance using our Live Testing Tool.

To meet these objectives, we have a multi-faceted approach. First, we aim to demonstrate the efficiency gains by using the Bootstrapper, highlighting the reduced number of steps needed to get the protocol up and running. Second, we plan to show how the Live Testing Tool can be an invaluable asset during the development phase, particularly for debugging and iterative testing. Lastly, we will present example tests that can be run on the new Proof of Authority protocol, showcasing the tool's versatility and utility in a real-world scenario.

\section{Boostrapping and Implementing Proof of Authority}

In this chapter, we delve into the implementation of a Proof of Authority (PoA) protocol. Unlike public, permissionless protocols like Proof of Work, PoA is a permissioned protocol. This means that only a select group of nodes, known as authorities or validators, are allowed to create new blocks.

Proof of Authority operates on the principle of reputation and trust. A small number of trusted nodes are given the authority to validate transactions and create new blocks. In our implementation, we replace the concept of mining with a list of these authorities. These validators are responsible for block creation and operate in a round-robin fashion.

The sequence in which these validators create blocks is determined by hashing. Specifically, for each round (or level, for simplicity), we hash the address (or Public Key hash) of each validator concatenated with the current round number. The hash function used is $H(address + round)$. These hashes are then used to sort the order of the validators, to decide the order of validators for the next round.


In case a validator fails to create a block, the protocol is designed to move on to the next validator in the sorted list. This process continues until a block is successfully created. This mechanism ensures both fairness and liveness in the protocol. Every node gets an opportunity to create blocks, and the protocol continues to function even if some nodes fail.

\textbf{Notice:} the way we order the validators is somewhat deterministic (unless validators fail). This has real-world implications and isn't necessarily a well designed protocol. 
To improve on this protocol, some sort of ``randomness'' should be added that is sourced from an outside entity. For example, using previous block information to sort the validators (for example, using the hash of the operations, or timestamp) wouldn't be a good way as the validator creating the block could have influence that information and in some way force the next block validator (to himself). This protocol was implemented just for demonstration purposes.

\section{Methodology}

To kickstart the development of our Proof of Authority protocol, we used the Bootstrapper tool with the command \textit{./bootstrapper -name poa -env 6}. This command sets up a new protocol, ensuring it's integrated into the Tezos build system. It also creates a folder with pre-made templates for various files, saving us from starting from scratch.

Since the Bootstrapper already provides files for account logic, storage, and monetary representations, our focus was mainly on filling in the protocol-specific logic. We began by defining the block header, which in our case only includes the "validator" and "authority\_list" values, along with the block's signature by the validator.

Next, we utilized the pre-provided storage file to implement the storage, logic, and representation of the validator set. This was followed by the core logic of the protocol, which is executed when a block is either received from the network or built by the node itself. This logic includes:

\begin{itemize}
    \item Verifying if the validator address in the header is authorized.
    \item Confirming if the block proposer is the expected one based on our round-robin logic.
    \item Checking the validity of the block's signature.
\end{itemize}

When the node receives a block from the network at a level above the expected one, it only verifies if the signature is correct and if the block validator/proposer is the expected one based on the information on the header.


We also implemented the logic for round selection and created an executable for the block creator, similar to the miner executable in the previous example. That is, in order for a node to be a validator one, it must have a baker attached to it, which is just an executable that keeps track of new blocks in the network and upon new blocks it checks if the account address associate to it is of the current proposer.

By following these steps, we were able to implement the protocol with minimal effort, focusing only on the protocol-specific logic. We only had to implement the logic behind the verification of the block header as well as the round-robin  mechanism.

While developing the protocol, we used the Live-testing tool with the following script, to test whether the network was executing and if the protocol works no matter the number of validators:

\begin{listing}[H]
\caption{Script to live test the Proof of Authority during development}
\label{lst:python_code}
\begin{minted}[fontsize=\footnotesize]{python}
protocol_name = "poa"
parameters = get_protocol_parameters(protocol_name)

number_of_validators = 5 # This can be changed to account for more/less validators

validators = []
for _ in range(number_of_validators):
    account = create_account() # Returns account with address, private and public keys
    accounts.append({key: account[key] for key in ('address', 'public_key')})
return accounts

start_test_response = start_test(
    protocol_name, number_of_validators, 0, parameters)

nodes = get_nodes() 

for i in range(number_of_validators):
    # Adds public and private key to node and starts baker
    add_key_and_propose(nodes[i], validators[i])
\end{minted}
\end{listing}



In summary, the Bootstrapper and Live Testing Tool significantly streamlined the development process of our Proof of Authority protocol. The Bootstrapper's template provided a strong foundation, allowing us to focus solely on the protocol-specific logic. This was evident in the number of lines of code written; out of the 6166 lines in the complete protocol, only 1700 were written by us. That's just 27% of the total codebase, emphasizing how much of the groundwork was already laid out.

This not only reduced the coding effort but also lowered the barrier to entry, as we didn't have to delve deep into the intricacies of protocol development. The Live Testing Tool further aided in debugging and validation, making the entire development cycle more efficient. Therefore, these tools prove to be invaluable assets for anyone looking to develop and test blockchain protocols with ease and efficiency.



\section{Evaluation and Insights: PoA vs PoW}

In this section, we aim to compare the key metrics of Proof of Authority (PoA) and Proof of Work (PoW) protocols. Specifically, we focus on the metric of Time-to-Consensus, which measures the time taken for a newly created block to be accepted by a majority of nodes or validators in the network. This comparison serves as a practical use-case for our developed tools and provides insights into the efficiency of different consensus algorithms.

To carry out this comparison, we used a script that simulates various network conditions for both PoA and PoW. This script is designed to measure the Time-to-Consensus under different configurations of block time and validator set size.


\begin{listing}[H]
\caption{Script to execute the tests for Time-to-Consensus}
\label{lst:python_code}
\begin{minted}[fontsize=\footnotesize]{python}
def start_protocol_test(protocol, n_validators, n_nodes, blocks_to_wait, blocks_to_run, block_time):

    print(f"Starting {pretty_name} test")
    parameters = get_protocol_parameters(protocol)
    parameters["constants"]["block_time"] = str(block_time)
    baker_name = "./octez-baker-custom-"
    accounts = create_multiple_accounts(n_validators)
    reveal_accounts = False

    if protocol == "poa":
        parameters["constants"]["initial_validator_set"] = [
            {key: account[key] for key in ('address', 'public_key')}
            for account in accounts
        ]
        baker_name = baker_name + "poa"
    else:
        reveal_accounts = True
        baker_name = baker_name + "demo"

    print("Starting the network")
    start_test(protocol, n_nodes, 0, parameters)
    wait_until_status("running")

    nodes = get_nodes()

    print("Starting the baker")
    processes = start_bakers(protocol, baker_name, accounts, nodes)

    print("Running the test....")
    wait_for_blocks(nodes[0]['rpc'], blocks_to_run)
    ttc = fetch_time_to_consensus()
    print(f"Final TTC: {ttc}")

    print("Stopping the test....")
    stop_test()
    wait_until_status("stopped")
    stop_bakers(processes)

    print(f"{pretty_name} test complete.")


tests = [
    {"validators": 10, "nodes": 10, "block_time": 30},
    {"validators": 20, "nodes": 20, "block_time": 30},
    {"validators": 10, "nodes": 20, "block_time": 20},
    {"validators": 30, "nodes": 30, "block_time": 20}
]


blocks_to_wait = 5
blocks_to_run_for = 25

for config in tests:
    for protocol in ["poa", "demo"]:
        start_protocol_test(protocol, config["validators"],
                            config["nodes"], blocks_to_wait, blocks_to_run_for, config["block_time"])
\end{minted}
\end{listing}


\section*{Expectations, Results and Observations}

Based on prior knowledge and the inherent characteristics of PoA and PoW, we expect the following outcomes:

\begin{itemize}
    \item PoA should exhibit a more consistent average Time-to-Consensus, irrespective of the block time and the size of the validator set.
    \item In PoW, the Time-to-Consensus is likely to increase with the number of validators, as a larger majority is needed to resolve forks and discard invalid blocks.
    \item Smaller block times in PoW are expected to result in longer Time-to-Consensus due to increased frequency of forks.
    \item The need for larger block times in PoW is evident, as shorter block times can lead to network instability and increased security risks.
\end{itemize}


We present the resulting statistics in the following table:

\definecolor{Gray}{gray}{0.9}
\definecolor{LightBlue}{rgb}{0.8, 0.9, 1}
\definecolor{LightRed}{rgb}{1, 0.8, 0.9}
\definecolor{LightYellow}{rgb}{0.0, 0.5, 0.5}

\begin{table}[h]
\centering
\caption{Time-to-Consensus Comparison between PoW and PoA}
\label{table:time-to-consensus}
\begin{tabular}{|c|c|c||c|c|c|}
\hline
\multicolumn{3}{|c||}{\textbf{Parameters}} & \multicolumn{3}{c|}{\textbf{Metrics (Time-to-Consensus)}} \\
\hline
\textbf{Validators} & \textbf{Nodes} & \textbf{Block Time} & \textbf{Max} & \textbf{Min} & \textbf{Average} \\
\hline
\multicolumn{6}{|c|}{\textbf{Proof of Work}} \\
\hline
\rowcolor{Gray}
10 & 10 & 30 & 117 & 10 & 50.959 \\
\rowcolor{LightBlue}
20 & 20 & 30 & 143 & 9 & 70.312 \\
\rowcolor{LightYellow}
10 & 20 & 20 & 143 & 10 & 65.229 \\
\rowcolor{LightRed}
30 & 30 & 20 & 191 & 20 & 72.332 \\
\hline
\multicolumn{6}{|c|}{\textbf{Proof of Authority}} \\
\hline
\rowcolor{Gray}
10 & 10 & 30 & 35 & 2 & 13.827 \\
\rowcolor{LightBlue}
20 & 20 & 30 & 38 & 1 & 14.233 \\
\rowcolor{LightYellow}
10 & 20 & 20 & 30 & 4 & 14.101 \\
\rowcolor{LightRed}
30 & 30 & 20 & 42 & 2 & 13.994 \\
\hline
\end{tabular}
\end{table}



Upon analyzing the results, we find that our expectations hold true:

\begin{itemize}
    \item PoA maintains a consistent average Time-to-Consensus (of about 14 seconds) across different configurations.
    \item PoW's Time-to-Consensus increases with the number of validators and decreases with larger block times, confirming its sensitivity to these parameters.
\end{itemize}

These observations validate the efficiency of PoA in achieving quicker consensus and highlight the limitations of PoW, especially in networks with smaller block times and larger validator sets.


\section{Conclusion}

In this chapter, we've demonstrated the power and utility of our developed tools—Bootstrapper and Live Testing Tool—in a real-world scenario. Through the lens of implementing and comparing two distinct consensus algorithms, Proof of Authority and Proof of Work, we've showcased how these tools can significantly streamline the protocol development and testing process.

The Bootstrapper tool allowed us to implement a fully functional PoA protocol with minimal effort, requiring us to write only 27\% of the total lines of code. This not only reduces the development time but also lowers the entry barrier for newcomers in the field of blockchain protocol development.

Our Live Testing Tool provided invaluable insights into key metrics like Time-to-Consensus, enabling us to make data-driven decisions and optimizations. The tool's flexibility and adaptability were evident as we easily configured it to test different network conditions, thereby obtaining a comprehensive understanding of the protocols' performance under various scenarios.

The comparative analysis between PoA and PoW further emphasized the importance of choosing the right consensus algorithm, and how our tools can aid in making that decision based on empirical data.

In summary, our tools offer a robust, efficient, and user-friendly environment for developing and testing blockchain protocols. They not only save time and effort but also provide the kind of deep insights that are crucial for the development of secure, efficient, and scalable blockchain networks.

